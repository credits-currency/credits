// Copyright (c) 2009-2010 Satoshi Nakamoto
// Copyright (c) 2009-2013 The Bitcoin developers
// Distributed under the MIT/X11 software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#ifndef BITCOIN_BITCOIN_CORE_H
#define BITCOIN_BITCOIN_CORE_H

#include "bitcoin_script.h"
#include "serialize.h"
#include "uint256.h"

#include "core.h"

#include <stdint.h>

class Bitcoin_CTransaction;

/** An inpoint - a combination of a transaction and an index n into its vin */
class Bitcoin_CInPoint
{
public:
    const Bitcoin_CTransaction* ptx;
    unsigned int n;

    Bitcoin_CInPoint() { SetNull(); }
    Bitcoin_CInPoint(const Bitcoin_CTransaction* ptxIn, unsigned int nIn) { ptx = ptxIn; n = nIn; }
    void SetNull() { ptx = NULL; n = (unsigned int) -1; }
    bool IsNull() const { return (ptx == NULL && n == (unsigned int) -1); }
};

/** An input of a transaction.  It contains the location of the previous
 * transaction's output that it claims and a signature that matches the
 * output's public key.
 */
class Bitcoin_CTxIn
{
public:
    COutPoint prevout;
    CScript scriptSig;
    unsigned int nSequence;

    Bitcoin_CTxIn()
    {
        nSequence = std::numeric_limits<unsigned int>::max();
    }

    explicit Bitcoin_CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), unsigned int nSequenceIn=std::numeric_limits<unsigned int>::max());
    Bitcoin_CTxIn(uint256 hashPrevTx, unsigned int nOut, CScript scriptSigIn=CScript(), unsigned int nSequenceIn=std::numeric_limits<unsigned int>::max());

    IMPLEMENT_SERIALIZE
    (
        READWRITE(prevout);
        READWRITE(scriptSig);
        READWRITE(nSequence);
    )

    bool IsFinal() const
    {
        return (nSequence == std::numeric_limits<unsigned int>::max());
    }

    friend bool operator==(const Bitcoin_CTxIn& a, const Bitcoin_CTxIn& b)
    {
        return (a.prevout   == b.prevout &&
                a.scriptSig == b.scriptSig &&
                a.nSequence == b.nSequence);
    }

    friend bool operator!=(const Bitcoin_CTxIn& a, const Bitcoin_CTxIn& b)
    {
        return !(a == b);
    }

    std::string ToString() const;
    void print() const;
};


/** The basic transaction that is broadcasted on the network and contained in
 * blocks.  A transaction can contain multiple inputs and outputs.
 */
class Bitcoin_CTransaction
{
public:
    static int64_t nMinTxFee;
    static int64_t nMinRelayTxFee;
    static const int CURRENT_VERSION=1;
    int nVersion;
    std::vector<Bitcoin_CTxIn> vin;
    std::vector<CTxOut> vout;
    unsigned int nLockTime;

    Bitcoin_CTransaction()
    {
        SetNull();
    }

    IMPLEMENT_SERIALIZE
    (
        READWRITE(this->nVersion);
        nVersion = this->nVersion;
        READWRITE(vin);
        READWRITE(vout);
        READWRITE(nLockTime);
    )

    void SetNull()
    {
        nVersion = Bitcoin_CTransaction::CURRENT_VERSION;
        vin.clear();
        vout.clear();
        nLockTime = 0;
    }

    bool IsNull() const
    {
        return (vin.empty() && vout.empty());
    }

    uint256 GetHash() const;

    // Return sum of txouts.
    int64_t GetValueOut() const;
    // GetValueIn() is a method on CCoinsViewCache, because
    // inputs must be known to compute value in.

    // Compute priority, given priority of inputs and (optionally) tx size
    double ComputePriority(double dPriorityInputs, unsigned int nTxSize=0) const;

    bool IsCoinBase() const
    {
        return (vin.size() == 1 && vin[0].prevout.IsNull());
    }

    friend bool operator==(const Bitcoin_CTransaction& a, const Bitcoin_CTransaction& b)
    {
        return (a.nVersion  == b.nVersion &&
                a.vin       == b.vin &&
                a.vout      == b.vout &&
                a.nLockTime == b.nLockTime);
    }

    friend bool operator!=(const Bitcoin_CTransaction& a, const Bitcoin_CTransaction& b)
    {
        return !(a == b);
    }


    std::string ToString() const;
    void print() const;
};

class Bitcoin_CTransactionCompressed
{
public:
    static const int CURRENT_VERSION=1;
    int nVersion;
	uint256 txHash;
    int64_t valueOut;
    std::vector<COutPoint> vin;
    //Only holds info whether the out is spendable or not. 0 == unspendable, 1 == spendable
    std::vector<bool> voutSpendable;

    //Memory only
    bool isCoinBase;
   std::vector<CTxOut> vout;
    bool isCreatedFromBlock;

    Bitcoin_CTransactionCompressed(const Bitcoin_CTransaction &tx, bool isCoinBaseIn)
    {
        SetNull();

		txHash = tx.GetHash();
		valueOut = tx.GetValueOut();
		isCoinBase = isCoinBaseIn;
		vin.reserve(tx.vin.size());
		for (unsigned int j = 0; j < tx.vin.size(); j++) {
			vin.push_back(tx.vin[j].prevout);
		}
		voutSpendable.reserve(tx.vout.size());
		vout.reserve(tx.vout.size());
		for (unsigned int j = 0; j < tx.vout.size(); j++) {
			voutSpendable.push_back(!tx.vout[j].scriptPubKey.IsUnspendable());
			vout.push_back(tx.vout[j]);
		}
		isCreatedFromBlock = true;
    }

    Bitcoin_CTransactionCompressed()
    {
        SetNull();
    }

    unsigned int GetSerializeSize(int nType, int nVersion) const {
        unsigned int nSize = 0;
        // version
        nSize += ::GetSerializeSize(VARINT(this->nVersion), nType, nVersion);
        nVersion = this->nVersion;
        nSize += ::GetSerializeSize(txHash, nType, nVersion);
        const uint64_t nValOut = CTxOutCompressor::CompressAmount(valueOut);
        nSize += ::GetSerializeSize(VARINT(nValOut), nType, nVersion);
        nSize += ::GetSerializeSize(vin, nType, nVersion);
    	//Size indicator
    	unsigned int nSpendableSize = voutSpendable.size();
        nSize += ::GetSerializeSize(VARINT(nSpendableSize), nType, nVersion);
        //Bit array of spentness
        nSize += nSpendableSize;
        return nSize;
    }

    template<typename Stream>
    void Serialize(Stream &s, int nType, int nVersion) const {
        // version
        ::Serialize(s, VARINT(this->nVersion), nType, nVersion);
        nVersion = this->nVersion;
        ::Serialize(s, txHash, nType, nVersion);
        const uint64_t nValOut = CTxOutCompressor::CompressAmount(valueOut);
        ::Serialize(s, VARINT(nValOut), nType, nVersion);
        ::Serialize(s, vin, nType, nVersion);
    	//Size indicator
    	unsigned int nSpendableSize = voutSpendable.size();
        ::Serialize(s, VARINT(nSpendableSize), nType, nVersion);
        //Bit array of spentness
        for (unsigned int b = 0; b*8 < nSpendableSize; b++) {
            unsigned char output = 0;
            for (unsigned int i = 0; i < 8 && b*8+i < nSpendableSize; i++) {
            	output |= (voutSpendable[b*8+i] << i);
            }
            ::Serialize(s, output, nType, nVersion);
        }
    }

    template<typename Stream>
    void Unserialize(Stream &s, int nType, int nVersion) {
        // version
        ::Unserialize(s, VARINT(this->nVersion), nType, nVersion);
        nVersion = this->nVersion;
        ::Unserialize(s, txHash, nType, nVersion);
        uint64_t nValOut = 0;
        ::Unserialize(s, VARINT(nValOut), nType, nVersion);
        valueOut = CTxOutCompressor::DecompressAmount(nValOut);
        ::Unserialize(s, vin, nType, nVersion);
    	//Size indicator
    	unsigned int nSpendableSize = 0;
        ::Unserialize(s, VARINT(nSpendableSize), nType, nVersion);
        //Bit array of spentness
        for (unsigned int b = 0; b*8 < nSpendableSize; b++) {
            unsigned char input = 0;
            ::Unserialize(s, input, nType, nVersion);
		   for(int i = 0; i < 8 && b*8+i < nSpendableSize; i++) {
			   voutSpendable.push_back(input & (1 << i));
		   }
        }
    }


    void SetNull()
    {
        nVersion = Bitcoin_CTransaction::CURRENT_VERSION;
    	txHash = uint256(0);
        valueOut = 0;
        vin.clear();
        voutSpendable.clear();
        isCoinBase = false;
        vout.clear();
        isCreatedFromBlock = false;
    }

    const uint256& GetHash() const {
    	return txHash;
    }

    bool IsCoinBase() const {
    	return isCoinBase;
    }

    bool IsCreatedFromBlock() const {
    	return isCreatedFromBlock;
    }

    int64_t GetValueOut() const {
    	return valueOut;
    }

    bool HasSpendable() const {
        BOOST_FOREACH(const int& spendable, voutSpendable) {
        	if(spendable) {
        		return true;
        	}
        }
        return false;
    }
};


/** Undo information for a CTxIn
 *
 *  Contains the prevout's CTxOut being spent, and if this was the
 *  last output of the affected transaction, its metadata as well
 *  (coinbase or not, height, transaction version)
 */
class Bitcoin_CTxInUndoClaim
{
public:
    CTxOutClaim txout;         // the txout data before being spent
    bool fCoinBase;       // if the outpoint was the last unspent: whether it belonged to a coinbase
    unsigned int nHeight; // if the outpoint was the last unspent: its height
    int nVersion;         // if the outpoint was the last unspent: its version

    Bitcoin_CTxInUndoClaim() : txout(), fCoinBase(false), nHeight(0), nVersion(0) {}
    Bitcoin_CTxInUndoClaim(const CTxOutClaim &txoutIn, bool fCoinBaseIn = false, unsigned int nHeightIn = 0, int nVersionIn = 0) : txout(txoutIn), fCoinBase(fCoinBaseIn), nHeight(nHeightIn), nVersion(nVersionIn) { }

    unsigned int GetSerializeSize(int nType, int nVersion) const {
        return ::GetSerializeSize(VARINT(nHeight*2+(fCoinBase ? 1 : 0)), nType, nVersion) +
               (nHeight > 0 ? ::GetSerializeSize(VARINT(this->nVersion), nType, nVersion) : 0) +
               ::GetSerializeSize(CTxOutClaimCompressor(REF(txout)), nType, nVersion);
    }

    template<typename Stream>
    void Serialize(Stream &s, int nType, int nVersion) const {
        ::Serialize(s, VARINT(nHeight*2+(fCoinBase ? 1 : 0)), nType, nVersion);
        if (nHeight > 0)
            ::Serialize(s, VARINT(this->nVersion), nType, nVersion);
        ::Serialize(s, CTxOutClaimCompressor(REF(txout)), nType, nVersion);
    }

    template<typename Stream>
    void Unserialize(Stream &s, int nType, int nVersion) {
        unsigned int nCode = 0;
        ::Unserialize(s, VARINT(nCode), nType, nVersion);
        nHeight = nCode / 2;
        fCoinBase = nCode & 1;
        if (nHeight > 0)
            ::Unserialize(s, VARINT(this->nVersion), nType, nVersion);
        ::Unserialize(s, REF(CTxOutClaimCompressor(REF(txout))), nType, nVersion);
    }
};

/** Undo information for a Bitcoin_CTransaction */
class Bitcoin_CTxUndoClaim
{
public:
    // undo information for all txins
    std::vector<Bitcoin_CTxInUndoClaim> vprevout;

    IMPLEMENT_SERIALIZE(
        READWRITE(vprevout);
    )
};


/** Undo information for a CTxIn
 *
 *  Contains the prevout's CTxOut being spent, and if this was the
 *  last output of the affected transaction, its metadata as well
 *  (coinbase or not, height, transaction version)
 */
class Bitcoin_CTxInUndo
{
public:
    CTxOut txout;         // the txout data before being spent
    bool fCoinBase;       // if the outpoint was the last unspent: whether it belonged to a coinbase
    unsigned int nHeight; // if the outpoint was the last unspent: its height
    int nVersion;         // if the outpoint was the last unspent: its version

    Bitcoin_CTxInUndo() : txout(), fCoinBase(false), nHeight(0), nVersion(0) {}
    Bitcoin_CTxInUndo(const CTxOut &txoutIn, bool fCoinBaseIn = false, unsigned int nHeightIn = 0, int nVersionIn = 0) : txout(txoutIn), fCoinBase(fCoinBaseIn), nHeight(nHeightIn), nVersion(nVersionIn) { }

    unsigned int GetSerializeSize(int nType, int nVersion) const {
        return ::GetSerializeSize(VARINT(nHeight*2+(fCoinBase ? 1 : 0)), nType, nVersion) +
               (nHeight > 0 ? ::GetSerializeSize(VARINT(this->nVersion), nType, nVersion) : 0) +
               ::GetSerializeSize(CTxOutCompressor(REF(txout)), nType, nVersion);
    }

    template<typename Stream>
    void Serialize(Stream &s, int nType, int nVersion) const {
        ::Serialize(s, VARINT(nHeight*2+(fCoinBase ? 1 : 0)), nType, nVersion);
        if (nHeight > 0)
            ::Serialize(s, VARINT(this->nVersion), nType, nVersion);
        ::Serialize(s, CTxOutCompressor(REF(txout)), nType, nVersion);
    }

    template<typename Stream>
    void Unserialize(Stream &s, int nType, int nVersion) {
        unsigned int nCode = 0;
        ::Unserialize(s, VARINT(nCode), nType, nVersion);
        nHeight = nCode / 2;
        fCoinBase = nCode & 1;
        if (nHeight > 0)
            ::Unserialize(s, VARINT(this->nVersion), nType, nVersion);
        ::Unserialize(s, REF(CTxOutCompressor(REF(txout))), nType, nVersion);
    }
};

/** Undo information for a Credits_CTransaction */
class Bitcoin_CTxUndo
{
public:
    // undo information for all txins
    std::vector<Bitcoin_CTxInUndo> vprevout;

    IMPLEMENT_SERIALIZE(
        READWRITE(vprevout);
    )
};


/** Nodes collect new transactions into a block, hash them into a hash tree,
 * and scan through nonce values to make the block's hash satisfy proof-of-work
 * requirements.  When they solve the proof-of-work, they broadcast the block
 * to everyone and the block is added to the block chain.  The first transaction
 * in the block is a special one that creates a new coin owned by the creator
 * of the block.
 */
class Bitcoin_CBlockHeader
{
public:
    // header
    static const int CURRENT_VERSION=2;
    int nVersion;
    uint256 hashPrevBlock;
    uint256 hashMerkleRoot;
    unsigned int nTime;
    unsigned int nBits;
    unsigned int nNonce;

    Bitcoin_CBlockHeader()
    {
        SetNull();
    }

    IMPLEMENT_SERIALIZE
    (
        READWRITE(this->nVersion);
        nVersion = this->nVersion;
        READWRITE(hashPrevBlock);
        READWRITE(hashMerkleRoot);
        READWRITE(nTime);
        READWRITE(nBits);
        READWRITE(nNonce);
    )

    void SetNull()
    {
        nVersion = Bitcoin_CBlockHeader::CURRENT_VERSION;
        hashPrevBlock = 0;
        hashMerkleRoot = 0;
        nTime = 0;
        nBits = 0;
        nNonce = 0;
    }

    bool IsNull() const
    {
        return (nBits == 0);
    }

    uint256 GetHash() const;

    int64_t GetBlockTime() const
    {
        return (int64_t)nTime;
    }
};


class Bitcoin_CBlock : public Bitcoin_CBlockHeader
{
public:
    // network and disk
    std::vector<Bitcoin_CTransaction> vtx;

    // memory only
    mutable std::vector<uint256> vMerkleTree;

    Bitcoin_CBlock()
    {
        SetNull();
    }

    Bitcoin_CBlock(const Bitcoin_CBlockHeader &header)
    {
        SetNull();
        *((Bitcoin_CBlockHeader*)this) = header;
    }

    IMPLEMENT_SERIALIZE
    (
        READWRITE(*(Bitcoin_CBlockHeader*)this);
        READWRITE(vtx);
    )

    void SetNull()
    {
        Bitcoin_CBlockHeader::SetNull();
        vtx.clear();
        vMerkleTree.clear();
    }

    Bitcoin_CBlockHeader GetBlockHeader() const
    {
        Bitcoin_CBlockHeader block;
        block.nVersion       = nVersion;
        block.hashPrevBlock  = hashPrevBlock;
        block.hashMerkleRoot = hashMerkleRoot;
        block.nTime          = nTime;
        block.nBits          = nBits;
        block.nNonce         = nNonce;
        return block;
    }

    uint256 BuildMerkleTree() const;

    const uint256 &GetTxHash(unsigned int nIndex) const {
        assert(vMerkleTree.size() > 0); // BuildMerkleTree must have been called first
        assert(nIndex < vtx.size());
        return vMerkleTree[nIndex];
    }

    std::vector<uint256> GetMerkleBranch(int nIndex) const;
    static uint256 CheckMerkleBranch(uint256 hash, const std::vector<uint256>& vMerkleBranch, int nIndex);
    void print() const;
};



#endif
